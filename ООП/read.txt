Объекты представляют собой набор свойств и методов.
Свойства объекта должны иметь разумные имена.
Так,например, если у нас есть объект person (человек), у него должны быть свойства
с названиями age (возраст) и lastName (фамилия) и заданными значениями. Перед
вами пример объекта:
let dog = { dogName: "JavaScript",
 weight: 2.4,
 color: "brown",
 breed: "chihuahua"
 };

Классы это особый вид функций.
Классы в JavaScript инкапсулируют данные и функции, которые являются частью
этого класса.
Если вы создадите класс, с его помощью вы сможете позже работать
над объектами, используя следующий синтаксис:

class ClassName {
 constructor(prop1, prop2) {
 this.prop1 = prop1;
 this.prop2 = prop2;
 }
}
let obj = new ClassName("arg1", "arg2");

Мы определили класс с именем ClassName, объявили переменную obj и сделали ее
новым экземпляром объекта. Приводятся два аргумента, они будут использоваться
конструктором для инициализации свойств.
Параметры для конструктора и свойства класса (prop1 и prop2) носят одинаковые названия. Свойства
класса можно распознать по ключевому слову this перед ними. Ключевое слово this
относится к объекту, которому принадлежит, поэтому является первым свойством
экземпляра ClassName.

Классы — это на самом деле просто особая функция.
Мы могли бы создать объект с помощью специальной функции,
типа этой:

function Dog(dogName, weight, color, breed) {
 this.dogName = dogName;
 this.weight = weight;
 this.color = color;
 this.breed = breed;
}
let dog = new Dog("Jacky", 30, "brown", "labrador");

Пример с собакой также можно реализовать
с использованием синтаксиса класса.

Выглядит это так:
class Dog2 {
 constructor(dogName, weight, color, breed) {
 this.dogName = dogName;
 this.weight = weight;
 this.color = color;
 this.breed = breed;
 }
}
let dog2 = new Dog2("JavaScript", 2.4, "brown", "chihuahua");
В результате получается объект с теми же свойствами.
Мы сможем это увидеть,
если проведем логирование следующим образом:
console.log(dog.dogName, "is a", dog.breed,
"and weighs", dog.weight, "kg.");

Вы можете задаться вопросом: если классы делают то же самое,
что и простое определение объекта, зачем они вообще нужны?
Ответ заключается в том, что классы,
по сути, являются схемами для объектов.
Если нужно создать 20 записей собак,
придется писать гораздо меньше кода, когда у нас есть класс dog.
При описывании
каждого объекта по отдельности нам придется каждый раз указывать
имена всех
свойств. И можно легко сделать опечатку или неправильно прописать свойство.
Классы пригодятся в подобных ситуациях.
Мы используем ключевое слово class, чтобы
сказать JavaScript, что хотим создать класс. 
Далее мы присваиваем имя классу.
По общепринятым правилам имена классов начинаются с заглавной буквы.
Рассмотрим различные элементы классов.

Метод constructor
Особый метод constructor используется для инициализации 
объектов с помощью классов. В классе может быть только один 
метод constructor. 
Он содержит свойства, которые будут установлены при инициализации класса.
Пример использования метода constructor при создании класса Person:
class Person {
 constructor(firstname, lastname) {
 this.firstname = firstname;
 this.lastname = lastname;
 }
}
JavaScript инициализирует специальную функцию, основанную на методе constructor. 
Эта функция получает имя класса и создает объект с заданными свойствами.
С помощью данной специальной функции можно прописывать экземпляры (объекты) класса.
Код, создающий новый объект на основе класса Person:
let p = new Person("Maaike", "van Putten");
Именно слово new дает понять JavaScript, что требуется искать специальную
функцию конструктора в классе Person и создавать новый объект. Конструктор
вызывается и возвращает экземпляр объекта person с заданными свойствами. Этот
объект сохраняется в переменной p.
Проверим - выведем в консоль
console.log("Hi", p.firstname);

!!Интересный момент
Если создать класс без каких-либо свойств.
let p = new Person("Maaike");
JavaScript присвоит оставшимся свойствам значение undefined.
console.log("Hi", p.firstname, p.lastname);

в конструкторе можно задать параметр по умолчанию

Практическое занятие
Выполните следующие действия, чтобы создать класс Person и вывести на
экран экземпляры имен друзей.
1.	 Создайте класс Person, включающий конструктор для firstname и lastname.
2.	 Создайте переменную и присвойте значение новому объекту Person, используя имя и фамилию вашего первого друга.
3.	 Теперь добавьте вторую переменную с именем второго друга, используя
его имя и фамилию.
4.	 Выведите на экран обе записи с приветствием hello.

Методы
В классе можно указывать функции.
Благодаря этому наш объект может начать
выполнять действия, используя собственные свойства, — например, выводить имя
на экран. Функции в классе называются методами.
Для определения таких методов не используется ключевое слово function.
Мы сразу начинаем писать названия метода.

В классе можно указывать любое количество методов.
В данном примере мы используем свойство firstname.
Создать еще один эеземпляр с другим свойством.

Методы, как и функции, могут принимать параметры и возвращать результаты.

Приватные свойства

Прямой доступ к свойствам лучше не предоставлять.
нужно подтвердить подтвердить, что возраст пользователя больше 18 лет.
Можно достичь этого, сделав
невозможным прямой доступ к свойству за пределами класса.
Ставим перед ними символ #.

конструктор с проверкой

Геттеры и сеттеры
Геттеры и сеттеры — это особые свойства, которые можно использовать для получения данных из класса и записи полей данных в классе.
Геттеры и сеттеры являются вычисляемыми свойствами.
Можно сказать, что они даже больше похожи на свойства, чем на функции.
Так же они называтся аксессорами (accessors).
Геттеры и сеттеры выглядят как функции, потому что после них ставят скобки (()),
но функциями они не являются!
Аксессоры начинаются с ключевых слов get и set.
Хорошей практикой считается максимально закрывать свойства и предоставлять доступ к ним с помощью геттеров и сеттеров.
Благодаря этому свойства не могут быть заданы извне без контроля самого объекта.
Подобный принцип называется инкапсуляцией.
Класс инкапсулирует (помещает) данные и объект под контроль собственных свойств.

Перейти к примеру PersonAccessor

Геттер используется для получения свойства.
Поэтому он не берет никаких параметров, а просто возвращает свойство.
Сеттер действует наоборот: принимает
параметр, присваивает новое значение свойству и ничего не возвращает.
Сеттер может включать в себя больше логики,
например проводить какую-то проверку (как в примере PersonAccessor).
Геттер можно использовать вне объекта, как если бы он был свойством.
Свойства больше не доступны напрямую извне класса, но к ним можно
получить доступ через геттер, возвращающий значение, и через сеттер, присваивающий значение.

Наследование
Наследование — одна из ключевых концепций ООП.
Согласно ей классы могут
иметь дочерние классы, которые наследуют свойства
и методы родительского класса.
Например, вы можете задать класс с названием ТРАНСПОРТНОЕ СРЕДСТВО,
в котором укажете некоторыеобщие свойства и методы объектов.
Для продолжения можете создавать дочерние
классы, основанные на классе ТРАНСПОРТНОЕ СРЕДСТВО, например ЛОДКА, МАШИНА, ВЕЛОСИПЕД и МОТОЦИКЛ.

Перейти к примеру Vehicle

С помощью ключевого слова extends мы указываем,
что определенный класс является дочерним по отношению к другому.
В данном случае Motorcycle — дочерний класс Vehicle.
Это значит, что у нас будет доступ к свойствам и методам класса
Vehicle в классе Motorcycle.
Сюда же мы добавили особый метод showWheel() для описания какой руль на конкретном траспорте.
Включать данную возможность в класс Vehicle не было смысла, потому что она специфична для определенных транспортных средств.
Слово super в конструкторе вызывает конструктор родителя — в данном случае
конструктор Vehicle. Это гарантирует, что поля от родителя также заданы и что
методы доступны без необходимости делать что-либо еще: они наследуются автоматически.
Вызов super() не является обязательным, но вы должны использовать
это ключевое слово при нахождении в классе, который наследуется от другого
класса — иначе получите ReferenceError.

В дочернем конструкторе перед использованием ключевого слова this вызывается super().
Вызов super() «привязывает» родительский конструктор к экземпляру.
super() должен идти на первом месте в дочернем конструкторе.

Для того, чтобы получить доступ к родительскому методу внутри дочернего класса,
следует использовать специальное сокращение super.

Родительский класс
class User {
    name
    constructor(name) {
        this.name = name
    }
    getName() {
        return this.name
    }
}
//Дочерний класс
class ContentWriter extends User {
    posts = []
    constructor(name, posts) {
        super(name)
        this.posts = posts
    }
    getName() {
        //использование родиьельского метода в дочернем классе
        const name = super.getName()
        if (name === '') {
            return 'Писатель'
        }
        return name
    }
}
const writer = new ContentWriter('Имя писателя', ['список произведений'])
writer.getName() // Писатель



Мы не можем получить доступ к каким-либо конкретным свойствам или методам
класса Motorcycle в классе Vehicle: не все транспортные средства являются мотоциклами,
поэтому мы не можем быть уверены, что при описании нашего конкретного
объекта понадобятся дочерние свойства или методы.
Сейчас мы не используем никаких геттеров и сеттеров, но определенно могли бы.
Если в родительском классе есть геттеры и сеттеры, они также наследуются дочерним классом.
Следовательно, мы могли бы влиять на то, какие свойства могут быть
извлечены и изменены (и как) за пределами нашего класса.
Обычно это хорошая практика.

Прототипы
Прототипы — это механизмы JavaScript, которые делают возможным существование объектов.
Если при создании класса никакие детали специально не уточняются, объекты наследуются от прототипа Object.prototype.
Среди всех встроенных классов JavaScript,
которые мы можем применять, этот довольно сложный.
Нет необходимости изучать,как он реализован.
Его можно считать базовым объектом, который всегда находится
на вершине дерева наследования, а значит, всегда присутствует в наших объектах.
Для всех классов доступно свойство prototype, и оно всегда называется «прототип».
Свойства тоже можно добвлять через прототип.

!! РАССКАЗ о ПРОТОТИПАХ
Это выглядит точно так же, как если бы вы определили класс с любимым цветом,
имеющим значение по умолчанию, и функцией introduce.
Они были добавлены
в класс и теперь доступны для всех экземпляров, существующих и будущих.
Следовательно, методы и свойства, определенные через prototype, точно такие
же, как если бы они были определены в классе.
Это означает, что, перезаписывая
их для определенного экземпляра, вы не перезаписываете методы и свойства всех
экземпляров. 
Прототипы не следует применять, если есть контроль над кодом класса и
 — в таком случае просто измените класс.
Однако с помощью прототипов вы можете расширить существующие объекты, в том числе
с применением условий.
Важно также знать, что встроенные объекты JavaScript
имеют прототипы и наследуют от Object.prototype.
Не меняйте данный прототип,иначе это повлияет на работу JavaScript.

ПРАКТИКА
Приложение для контроля сотрудников
Создайте класс для контроля сотрудников компании.
1.	 Используйте имена, фамилии и количество отработанных лет в качестве значений в конструкторе.
2.	 Создайте записи о двух или более сотрудниках со значениями их имен, фамилий и количества лет, которые они проработали в компании. Добавьте этих
людей в массив.
3.	 Создайте прототип, чтобы возвращать данные об имени и фамилии человека
и о том, как долго он проработал в компании.
4.	 Повторите содержимое массива для вывода результатов на экран

Расчет стоимости заказов
Создайте класс, который позволит рассчитать совокупную цену ряда товаров
и взаимодействовать с ней, чтобы узнать общую стоимость различных заказов.
1.	 Создайте класс, содержащий цены двух пунктов прейскуранта в качестве объявлений частных полей.
2.	 Используйте конструктор в классе, чтобы получить значения аргументов
(сколько покупается каждого товара).
3.	 Создайте метод для расчета и возврата общей стоимости в зависимости от того,
сколько товаров выбирает пользователь.
4.	 Используйте геттер, чтобы получить значение, выводимое методом расчета.
5.	 Создайте два или три объекта с различными комбинациями пунктов прейскуранта и выведите общую стоимость на экран.



